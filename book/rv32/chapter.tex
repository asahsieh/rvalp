
\newcommand\instructionHeader[1]{{\large\tt \string#1}}

\chapter{RV32 Machine Instructions}
\label{chapter:RV32}
\index{RV32}

\section{Introduction}

{\em XXX NOTE: This is a first draft of what is being detailed in the previous chapter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conventions and Terminology}

When discussing instructions, the following abbreviations/notations are used:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{XLEN}

XLEN represents the bit-length of an \reg{x} register in the machine architecture.
Possible values are 32, 64 and 128.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{sx(val)}
\label{extension:sx}

Sign extend {\em val} to the left.

This is used to convert a signed integer value expressed using some number of 
bits to a larger number of bits by adding more bits to the left.  In doing so, 
the sign will be preserved.  In this case {\em val} represents the least 
\acrshort{msb}s of the value.  

For more on sign-extension see \autoref{SignExtension}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{zx(val)}
\label{extension:zx}

Zero extend {\em val} to the left.

This is used to convert an unsigned integer value expressed using some number of 
bits to a larger number of bits by adding more bits to the left.  In doing so, 
the new bits added will all be set to zero.  As is the case with \verb@sx(val)@,
{\em val} represents the \acrshort{lsb}s of the final value.  

For more on zero-extension see \autoref{ZeroExtension}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{zr(val)}
\label{extension:zr}

Zero extend {\em val} to the right.

Some times a binary value is encoded such that a set of bits represented
by {\em val} are used to represent the \acrshort{msb}s of some longer (more bits) 
value.  
In this case it is necessary to append zeros to the right to convert \verb@val@ to 
the longer value.

\autoref{Figure:ZeroRightExtend} illustrates converting a 20-bit {\em val} to
a 32-bit fullword.

\begin{figure}[ht]
\centering
\DrawBitBoxSignLeftZeroRightExtendedPicture{32}{01000000000000000010}{12}
\captionof{figure}{Zero-extending an integer to the right from 20 bits to 32 bits.}
\label{Figure:ZeroRightExtend}
\end{figure}

%\begin{figure}[ht]
%\centering
%\parbox{.7\linewidth}{
%\DrawBitBoxUnsignedPicture{01000000000000000010}\\
%\DrawBitBoxUnsignedPicture{01000000000000000010000000000000}
%}
%\captionof{figure}{Zero-extending an integer to the right from 20 bits to 32 bits.}
%\label{Figure:ZeroRightExtend}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sign Extended Left and Zero Extend Right}
\label{extension:slzr}

Some instructions such as the J-type (see \autoref{insnformat:jtype}) include
immediate operands that are extended in both directions.

\autoref{Figure:slzrPositive} and \autoref{Figure:slzrNegative}
illustrates zero-extending a 20-bit negative number one bit to the right 
and sign-extending it 11 bits to the left:

\begin{figure}[ht]
\centering
\DrawBitBoxSignLeftZeroRightExtendedPicture{32}{01000100011101001001}{1}
\captionof{figure}{Sign-extending a positive 20-bit number 
11 bits to the left and one bit to the right.}
\label{Figure:slzrPositive}
\end{figure}

\begin{figure}[ht]
\centering
\DrawBitBoxSignLeftZeroRightExtendedPicture{32}{11000100011101001001}{1}
\captionof{figure}{Sign-extending a negative 20-bit number 
11 bits to the left and one bit to the right.}
\label{Figure:slzrNegative}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{m8(addr)}
\label{memory:m8}

The contents of an 8-bit value in memory at address {\em addr}.

Given the contents of the memory dump shown in 
\autoref{Figure:SampleMemoryContents}, 
\verb@m8(42)@ refers to the memory location at address \verb@42@$_{16}$ 
that currently contains the 8-bit value \verb@fc@$_{16}$.

The \verb@mn(addr)@ notation can be used to refer to memory that is being 
read or written depending on the context.  

When memory is being written, the following notation is used to indicate that 
the least significant 8 bis of {\em source} will be is written into memory at 
the address {\em addr}:

\verb@m8(addr)@ $\leftarrow$ \verb@source@

When memory is being read, the following notation is used to indicate that the 
8 bit value at the address {\em addr} will be read and stored into {\em dest}:

\verb@dest@ $\leftarrow$ \verb@m8(addr)@ 

Note that {\em source} and {\em dest} are typically registers.
 

\begin{figure}[ht]
\centering
\begin{BVerbatim}


00000030  2f 20 72 65 61 64 20 61  20 62 69 6e 61 72 79 20
00000040  66 69 fc 65 20 66 69 6c  6c 65 64 20 77 69 74 68
00000050  20 72 76 33 32 49 20 69  6e 73 74 72 75 63 74 69
00000060  6f 6e 73 20 61 6e 64 20  66 65 65 64 20 74 68 65
\end{BVerbatim}
\captionof{figure}{Sample memory contents.}
\label{Figure:SampleMemoryContents}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{m16(addr)}

The contents of an 16-bit little-endian value in memory at address {\em addr}.

Given the contents of the memory dump shown in 
\autoref{Figure:SampleMemoryContents}, 
\verb@m16(42)@ refers to the memory location at address \verb@42@$_{16}$
that currently contains \verb@65fc@$_{16}$. See also~\autoref{memory:m8}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{m32(addr)}

The contents of an 32-bit little-endian value in memory at address {\em addr}.

Given the contents of the memory dump shown in
\autoref{Figure:SampleMemoryContents},
\verb@m32(42)@ refers to the memory location at address \verb@42@$_{16}$
that currently contains \verb@662065fc@$_{16}$.
See also~\autoref{memory:m8}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{m64(addr)}

The contents of an 64-bit little-endian value in memory at address {\em addr}.

Given the contents of the memory dump shown in 
\autoref{Figure:SampleMemoryContents}, 
\verb@m64(42)@ refers to the memory location at address \verb@42@$_{16}$
that currently contains \verb@656c6c69662065fc@$_{16}$.
See also~\autoref{memory:m8}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{m128(addr)}

The contents of an 128-bit little-endian value in memory at 
address {\em addr}.

Given the contents of the memory dump shown in 
\autoref{Figure:SampleMemoryContents}, 
\verb@m128(42)@ refers to the memory location at address \verb@42@$_{16}$
that currently contains \verb@7220687469772064656c6c69662065fc@$_{16}$.
See also~\autoref{memory:m8}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{.+offset}

The address of the current instruction plus a numeric offset.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{.-offset}

The address of the current instruction minus a numeric offset.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{pc}

The current value of the program counter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{rd}

An x-register used to store the result of instruction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{rs1}

An x-register value used as a source operand for an instruction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{rs2}

An x-register value used as a source operand for an instruction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{imm}

An immediate numeric operand.  The word {\em immediate} refers
to the fact that the operand is stored within an instruction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{rsN[h:l]}

The value of bits from {\em h} through {\em l} of x-register rsN.
For example: rs1[15:0] refers to the contents of 
the 16 \acrshort{lsb}s of rs1.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Addressing Modes}

immediate, register, base-displacement, pc-relative
\enote{Write this section.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Instruction Encoding Formats}
\label{section:EncodingFormats}


%XXX Show and discuss a stack of formats explaining how the unnatural ordering
%of the {\em imm} fields reduces the number of possible locations that 
%the hardware has to be prepared to {\em look} for various bits.  For example,
%the opcode, rd, rs1, rs1, func3 and the sign bit (when used) are all always 
%in the same position.  Also note that imm[19:12] and imm[10:5] can only be 
%found in one place.  imm[4:0] can only be found in one of two places\ldots

The method/format of an instruction is designed with an eye on the ease
of future manufacture of the machine that will execute them.  It is 
easier to build a machine if it does not have to accommodate many different 
ways to perform the same task.  The result is that a machine can be 
built with fewer gates, consumes less power, and can run faster than
if it were built when a priority is on how a user might prefer to decode
the same instructions from a hex dump.

This document concerns itself with the RISC-V instruction formats shown 
in \autoref{Figure:riscvFormats}.

%\autoref{Figure:riscvFormats} Shows the RISC-V instruction formats.

\begin{figure}[ht]
\DrawInsnTypeBTikz{00000000000000000000000000000000}\\
\DrawInsnTypeUTikz{00000000000000000000000000000000}\\
\DrawInsnTypeJTikz{00000000000000000000000000000000}\\
\DrawInsnTypeITikz{00000000000000000000000000000000}\\
\DrawInsnTypeIShiftTikz{00000000000000000000000000000000}\\
\DrawInsnTypeSTikz{00000000000000000000000000000000}\\
\DrawInsnTypeRTikz{00000000000000000000000000000000}
\captionof{figure}{RISC-V instruction formats.}
\label{Figure:riscvFormats}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{U Type}
\label{insnformat:utype}

The U-Type format is used for instructions that use a 20-bit immediate operand 
and a destination register.
 
\DrawInsnTypeUTikz{11010110000000000011001010110111}

The \reg{rd} field contains an \reg{x} register number to be set to a value that
depends on the instruction.

The imm field 
contains a 20-bit value that will be converted into \Gls{xlen} bits by 
using the {\em imm} operand for bits 31:12 and then sign-extending it 
to the left\footnote{When XLEN is larger than 32.} and zero-extending 
the LSBs as discussed in \autoref{extension:zr}.

If \Gls{xlen}=32 then the {\em imm} value example will extracted from the instruction
and converted as shown in \autoref{Figure:u_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpUTypeDecoding
\captionof{figure}{Decoding a U-type instruction.}
\label{Figure:u_type_decode}
\label{imm.u:decode}
\index{imm\protect\_u}
\end{figure}

Notice that the 20-bits of the imm field are mapped in the same order and 
in the same relative position that they appear in the instruction when 
they are used to create the value of the immediate operand.  
Shifting the imm value to the left, into the ``upper bits'' of the immediate 
value suggests a rationale for the name of this format.

%from $01010110000000000011_2$ (\verb@d6003@$_{16}$) to 
%$11010110000000000011000000000000_2$ (\verb@d6003000@$_{16}$).


\begin{itemize}
\item\instructionHeader{lui\ \ \ rd,imm}
\label{insn:lui}

Set register \verb@rd@ to the \verb@imm_u@ value as shown in \autoref{Figure:u_type_decode}.  

For example: \verb@lui x23,0x12345@ will result in setting register \verb@x23@ to 
the value \verb@0x12335000@.

\item\instructionHeader{auipc rd,imm}
\label{insn:auipc}

Add the address of the instruction to the \verb@imm_u@ value as 
shown \autoref{Figure:u_type_decode} and store the result in register \verb@rd@.

For example, if the instruction \verb@auipc x22,0x10001@ is executed from
memory address \verb@0x800012f4@ then register \verb@x22@ will be set to 
\verb@0x900022f4@.
\end{itemize}



If \Gls{xlen}=64 then the \verb@imm_u@ value in this example will be converted to the
same two's complement integer value by extending the sign-bit (indicated by \verb@a@ 
in \autoref{Figure:u_type_decode}) to the left.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{J Type}
\label{insnformat:jtype}

The J-type format is used for instructions that use a 20-bit immediate operand
and a destination register.  It is similar to the U-type.  However, the immediate
operand is constructed by arranging the {\em imm} bits in a different manner.

\DrawInsnTypeJTikz{00111001001110000001001111101111}

The \reg{rd} field contains an \reg{x} register number to be set to a value that
depends on the instruction.


In the J-type format the 20 {\em imm} bits are arranged such 
that they represent the ``lower'' portion of the immediate value.  Unlike 
the U-type 
instructions, the J-type requires the bits to be re-ordered and shifted 
to the right before they are used.\footnote{The reason that the J-type 
bits are reordered like this is because it simplifies the implementation of 
hardware as discussed in \autoref{section:EncodingFormats}.}

The example above shows that the bit positions in the {\em imm} field 
description.  We see that the 20 {\em imm} bits are re-ordered according to: 
[20\textbar10:1\textbar11\textbar19:12].  
This means that the \acrshort{msb} of the {\em imm} field is to be placed 
into bit 20 of the immediate integer value ultimately used by the instruction 
when it is converted into \Gls{xlen} bits.  
The next bit to the right in the {\em imm} field is to be placed into bit 10 of 
the immediate value and so on.

After the {\em imm} bits are re-positioned into bits 20:1 of the immediate value
being constructed, a zero-bit will be added to the \acrshort{lsb} 
and the value in bit-position 20 will be replicated to sign-extend the 
value to \Gls{xlen} bits as discussed in \autoref{extension:slzr}.


If \Gls{xlen}=32 then the {\em imm} value example will extracted from the instruction
and converted as shown in \autoref{Figure:j_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpJTypeDecoding
\captionof{figure}{Decoding a J-type instruction.}
\label{Figure:j_type_decode}
\label{imm.j:decode}
\index{imm\protect\_j}
\end{figure}


%\DrawBitBoxSignLeftZeroRightExtendedPicture{32}{01000000110111001001}{1}
%
%A J-type example with a negative imm field:
%
%\DrawInsnTypeJTikz{10111001001110000001001111101111}
%
%If \Gls{xlen}=32 then the {\em imm} field in this example will be converted as 
%shown below.
%
%\DrawBitBoxSignLeftZeroRightExtendedPicture{32}{11000000110111001001}{1}

The J-type format is used by the Jump And Link instruction that calculates 
a target address by adding a signed immediate value to the current program 
counter.  Since no instruction can be placed at an odd address the 20-bit 
imm value is zero-extended to the right to represent a 21-bit signed offset 
capable of representing numbers twice the magnitude of the 20-bit imm value.

\begin{itemize}
\item\instructionHeader{jal\ \ \ rd,imm}
\label{insn:jal}

Set register \verb@rd@ to the address of the next instruction that would 
otherwise be executed (the address of the \verb@jal@ instruction + 4) and then
jump to an address given by the sum of the \verb@pc@ register and the 
\verb@imm_j@ value as decoded from the instruction shown in \autoref{imm.j:decode}.



\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{R Type}
\label{insnformat:rtype}
\DrawInsnTypeRTikz{01000001111100011000001110110011}

The R-type instructions are used for operations that set a destination 
register \verb@rd@ to the result of an arithmetic, logical or shift operation
applied to source registers \verb@rs1@ and \verb@rs2@.

Note that bit 30 is used to select between the \verb@add@ and \verb@sub@ instructions
as well as to select between arithmetic and logical shifting.

\begin{itemize}
\item\instructionHeader{add\ \ \ rd,rs1,rs2}
\label{insn:add}

Set register \verb@rd@ to \verb@rs1 + rs2@.

\item\instructionHeader{and\ \ \ rd,rs1,rs2}
\label{insn:and}

Set register \verb@rd@ to the bitwise \verb@and@ of \verb@rs1@ and  \verb@rs2@.

For example, if \verb@x17@ = \verb@0x55551111@ and \verb@x18@ = \verb@0xff00ff00@
then the instruction \verb@xor x12,x17,x18@ will set \verb@x12@ to the
value \verb@0x55001100@.

\item\instructionHeader{or\ \ \ \ rd,rs1,rs2}
\label{insn:or}

Set register \verb@rd@ to the bitwise \verb@or@ of \verb@rs1@ and  \verb@rs2@.

For example, if \verb@x17@ = \verb@0x55551111@ and \verb@x18@ = \verb@0xff00ff00@
then the instruction \verb@xor x12,x17,x18@ will set \verb@x12@ to the
value \verb@0xff55ff11@.

\item\instructionHeader{sll\ \ \ rd,rs1,rs2}
\label{insn:sll}

Shift \verb@rs1@ left by the number of bits given in \verb@rs2@ and
store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x12345678@ and \verb@x18@ = \verb@0x08@
then the instruction \verb@sll x12,x17,x18@ will set \verb@x12@ to the
value \verb@0x34567800@.

\item\instructionHeader{slt\ \ \ rd,rs1,rs2}
\label{insn:slt}

If the signed integer value in \verb@rs1@ is less than the
signed integer value in \verb@rs2@ then set \verb@rd@ to \verb@1@.
Otherwise, set \verb@rd@ to \verb@0@.

\item\instructionHeader{sltu\ \ rd,rs1,rs2}
\label{insn:sltu}

If the unsigned integer value in \verb@rs1@ is less than the
unsigned integer value in \verb@rs2@ then set \verb@rd@ to \verb@1@.
Otherwise, set \verb@rd@ to \verb@0@.

\item\instructionHeader{sra\ \ \ rd,rs1,rs2}
\label{insn:sra}

Logic-shift \verb@rs1@ right by the number of bits given in \verb@rs2@ and
store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x87654321@ and \verb@x18@ = \verb@0x08@
then the instruction \verb@sll x12,x17,x18@ will set \verb@x12@ to the
value \verb@0xff876543@.

\item\instructionHeader{srl\ \ \ rd,rs1,rs2}
\label{insn:srl}

Logic-shift \verb@rs1@ right by the number of bits given in \verb@rs2@ and
store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x87654321@ and \verb@x18@ = \verb@0x08@
then the instruction \verb@sll x12,x17,x18@ will set \verb@x12@ to the
value \verb@0x00876543@.

\item\instructionHeader{sub\ \ \ rd,rs1,rs2}
\label{insn:sub}

Set register \verb@rd@ to \verb@rs1 - rs2@.

\item\instructionHeader{xor\ \ \ rd,rs1,rs2}
\label{insn:xor}

Set register \verb@rd@ to the bitwise \verb@xor@ of \verb@rs1@ and  \verb@rs2@.

For example, if \verb@x17@ = \verb@0x55551111@ and \verb@x18@ = \verb@0xff00ff00@
then the instruction \verb@xor x12,x17,x18@ will set \verb@x12@ to the
value \verb@0xaa55ee11@.

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{I Type}
\label{insnformat:itype}
\DrawInsnTypeITikz{00000000010000011000001110000011}

If \Gls{xlen}=32 then the {\em imm} value example will extracted from the instruction
and converted as shown in \autoref{Figure:i_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpITypeDecoding
\captionof{figure}{Decoding an I-type Instruction.}
\label{Figure:i_type_decode}
\label{imm.i:decode}
\index{imm\protect\_i}
\end{figure}

A special case of the I-type used for shift-immediate instructions where 
the {\em imm} field is used as an immediate value named {\em shamt\_i} 
representing the number of bit positions to shift as shown in 
\autoref{Figure:shamt_i_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpIShiftTypeDecoding
\captionof{figure}{Decoding an I-type Shift Instruction.}
\label{Figure:shamt_i_type_decode}
\label{shamt.i:decode}
\index{shamt\protect\_i}
\end{figure}

Note that bit 30 is used to select between arithmetic and logical shifting.

\begin{figure}[ht]
\centering
\begin{verbatim}
 00002640: 6f 00 00 00 6f 00 00 00  b7 87 00 00 03 a5 07 43 *o...o..........C*
 00002650: 67 80 00 00 00 00 00 00  76 61 6c 3d 00 00 00 00 *g.......val=....*
 00002660: 00 00 00 00 80 84 2e 41  1f 85 45 41 80 40 9a 44 *.......A..EA.@.D*
 00002670: 4f 11 f3 c3 6e 8a 67 41  20 1b 00 00 20 1b 00 00 *O...n.gA ... ...*
 00002680: 44 1b 00 00 14 1b 00 00  14 1b 00 00 04 1c 00 00 *D...............*
\end{verbatim}
\captionof{figure}{An Example Memory Dump.}
\label{Figure:imm:memory:dump}
\end{figure}


\begin{itemize}
\item\instructionHeader{addi\ \ rd,rs1,imm}
\label{insn:addi}

Set register \verb@rd@ to \verb@rs1 + imm_i@.

\item\instructionHeader{andi\ \ rd,rs1,imm}
\label{insn:andi}

Set register \verb@rd@ to the bitwise \verb@and@ of \verb@rs1@ and \verb@imm_i@.

For example, if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@andi x12,x17,0x0ff@ will set \verb@x12@ to the value \verb@0x00000011@.

Recall that \verb@imm@ is sign-extended.  
Therefore if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@andi x12,x17,0x800@ will set \verb@x12@ to the value \verb@0x55551000@.

\item\instructionHeader{jalr\ \ rd,rs1,imm}
\label{insn:jalr}

Set register \verb@rd@ to the address of the next instruction that would 
otherwise be executed (the address of the \verb@jalr@ instruction + 4) and then 
jump to an address given by the sum of the \verb@pc@ register and the 
\verb@imm_i@ value as decoded from the instruction shown in \autoref{imm.i:decode}.

Note that the \verb@pc@ register can never refer to an odd address.  
This instruction will explicitly set the \acrshort{lsb} to zero regardless
of the value of \verb@rs1@.

\item\instructionHeader{lb\ \ \ \ rd,imm(rs1)}
\label{insn:lb}

Set register \verb@rd@ to the value of the sign-extended byte fetched from 
the memory address given by the sum of \verb@rs1@ and \verb@imm_i@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lb x12,1(x13)@ will set \verb@x12@ to the value \verb@0xffffff80@.

\item\instructionHeader{lbu\ \ \ rd,imm(rs1)}
\label{insn:lbu}

Set register \verb@rd@ to the value of the zero-extended byte fetched from 
the memory address given by the sum of \verb@rs1@ and \verb@imm_i@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lb x12,1(x13)@ will set \verb@x12@ to the value \verb@0x00000080@.

\item\instructionHeader{lh\ \ \ \ rd,imm(rs1)}
\label{insn:lh}

Set register \verb@rd@ to the value of the sign-extended 16-bit little-endian 
half-word value fetched from the memory address given by the sum 
of \verb@rs1@ and \verb@imm_i@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lh x12,-2(x13)@ will set \verb@x12@ to the value \verb@0x00004307@.

If register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lh x12,-8(x13)@ will set \verb@x12@ to the value \verb@0xffff87b7@.

\item\instructionHeader{lhu\ \ \ rd,imm(rs1)}
\label{insn:lhu}

Set register \verb@rd@ to the value of the zero-extended 16-bit little-endian 
half-word value fetched from the memory address given by the sum 
of \verb@rs1@ and \verb@imm_i@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lhu x12,-2(x13)@ will set \verb@x12@ to the value \verb@0x00004307@.

If register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lhu x12,-8(x13)@ will set \verb@x12@ to the value \verb@0x000087b7@.

\item\instructionHeader{lw\ \ \ \ rd,imm(rs1)}
\label{insn:lw}

Set register \verb@rd@ to the value of the sign-extended 32-bit little-endian 
word value fetched from the memory address given by the sum 
of \verb@rs1@ and \verb@imm_i@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if register \verb@x13@ = \verb@0x00002650@ then the instruction
\verb@lh x12,-4(x13)@ will set \verb@x12@ to the value \verb@4307a503@.


\item\instructionHeader{ori\ \ \ rd,rs1,imm}
\label{insn:ori}

Set register \verb@rd@ to the bitwise \verb@or@ of \verb@rs1@ and \verb@imm_i@.

For example, if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@ori x12,x17,0x0ff@ will set \verb@x12@ to the value \verb@0x555511ff@.

Recall that \verb@imm@ is sign-extended.
Therefore if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@ori x12,x17,0x800@ will set \verb@x12@ to the value \verb@0xfffff911@.

\item\instructionHeader{slli\ \ rd,rs1,imm}
\label{insn:slli}

Shift \verb@rs1@ left by the number of bits given in \verb@shamt_i@ 
(as shown in \autoref{shamt.i:decode}) and store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x12345678@ then the instruction 
\verb@slli x12,x17,4@ will set \verb@x12@ to the value \verb@0x23456780@.

\item\instructionHeader{slti\ \ rd,rs1,imm}
\label{insn:slti}

If the signed integer value in \verb@rs1@ is less than the
signed integer value in \verb@imm_i@ then set \verb@rd@ to \verb@1@.
Otherwise, set \verb@rd@ to \verb@0@.

\item\instructionHeader{sltiu\ rd,rs1,imm}
\label{insn:sltiu}

If the unsigned integer value in \verb@rs1@ is less than the
unsigned integer value in \verb@imm_i@ then set \verb@rd@ to \verb@1@.
Otherwise, set \verb@rd@ to \verb@0@.

Note that \verb@imm_i@ is always created by sign-extending the \verb@imm@ value 
as shown in \autoref{imm.i:decode} even though it is then later used as an unsigned 
integer for the purposes of comparing its magnitude to the unsigned value in rs1.  
Therefore, this instruction provides a method to compare \verb@rs1@ to a value 
in the ranges of 
$[\text{\tt 0}..\text{\tt 0x7ff}]$ and $[\text{\tt 0xfffff800}..\text{\tt 0xffffffff}]$.

\item\instructionHeader{srai\ \ rd,rs1,imm}
\label{insn:srai}

Arithmetic-shift \verb@rs1@ right by the number of bits given in \verb@shamt_i@
(as shown in \autoref{shamt.i:decode}) and store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x87654321@ then the instruction 
\verb@srai x12,x17,4@ will set \verb@x12@ to the value \verb@0xf8765432@.

\item\instructionHeader{srli\ \ rd,rs1,imm}
\label{insn:srli}

Logic-shift \verb@rs1@ right by the number of bits given in \verb@shamt_i@
(as shown in \autoref{shamt.i:decode}) and store the result in \verb@rd@.

For example, if \verb@x17@ = \verb@0x87654321@ then the instruction 
\verb@srli x12,x17,4@ will set \verb@x12@ to the value \verb@0x08765432@.

\item\instructionHeader{xori\ \ rd,rs1,imm}
\label{insn:xori}

Set register \verb@rd@ to the bitwise \verb@xor@ of \verb@rs1@ and \verb@imm_i@.

For example, if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@xori x12,x17,0x0ff@ will set \verb@x12@ to the value \verb@0x555511ee@.

Recall that \verb@imm@ is sign-extended.
Therefore if \verb@x17@ = \verb@0x55551111@ then the instruction 
\verb@xori x12,x17,0x800@ will set \verb@x12@ to the value \verb@0xaaaae911@.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{S Type}
\label{insnformat:stype}
\DrawInsnTypeSTikz{00000000111100011000100110100011}

If \Gls{xlen}=32 then the {\em imm} value example will extracted from the instruction
and converted as shown \autoref{Figure:imm_s_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpSTypeDecoding
\captionof{figure}{Decoding an S-type Instruction.}
\label{Figure:imm_s_type_decode}
\label{imm.s:decode}
\index{imm\protect\_s}
\end{figure}

\begin{itemize}
\item\instructionHeader{sb\ \ \ \ rs2,imm(rs1)}
\label{insn:sb}

Set the byte of memory at the address given by the sum of \verb@rs1@ and 
\verb@imm_s@ to the 8 \acrshort{lsb}s of \verb@rs2@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if registers \verb@x13@ = \verb@0x00002650@ and \verb@x12@ = \verb@0x12345678@
then the instruction \verb@sb x12,1(x13)@ will change the memory byte at address 
\verb@0x00002651@ from \verb@0x80@ to \verb@0x78@ resulting in:

\begin{verbatim}
 00002640: 6f 00 00 00 6f 00 00 00  b7 87 00 00 03 a5 07 43 *o...o..........C*
 00002650: 67 78 00 00 00 00 00 00  76 61 6c 3d 00 00 00 00 *gx......val=....*
 00002660: 00 00 00 00 80 84 2e 41  1f 85 45 41 80 40 9a 44 *.......A..EA.@.D*
 00002670: 4f 11 f3 c3 6e 8a 67 41  20 1b 00 00 20 1b 00 00 *O...n.gA ... ...*
 00002680: 44 1b 00 00 14 1b 00 00  14 1b 00 00 04 1c 00 00 *D...............*
\end{verbatim}

\item\instructionHeader{sh\ \ \ \ rs2,imm(rs1)}
\label{insn:sh}

Set the 16-bit half-word of memory at the address given by the sum of \verb@rs1@ and 
\verb@imm_s@ to the 16 \acrshort{lsb}s of \verb@rs2@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if registers \verb@x13@ = \verb@0x00002650@ and \verb@x12@ = \verb@0x12345678@
then the instruction \verb@sh x12,2(x13)@ will change the memory half-word at 
address \verb@0x00002652@ from \verb@0x0000@ to \verb@0x5678@ resulting in:

\begin{verbatim}
 00002640: 6f 00 00 00 6f 00 00 00  b7 87 00 00 03 a5 07 43 *o...o..........C*
 00002650: 67 80 78 56 00 00 00 00  76 61 6c 3d 00 00 00 00 *g.xV....val=....*
 00002660: 00 00 00 00 80 84 2e 41  1f 85 45 41 80 40 9a 44 *.......A..EA.@.D*
 00002670: 4f 11 f3 c3 6e 8a 67 41  20 1b 00 00 20 1b 00 00 *O...n.gA ... ...*
 00002680: 44 1b 00 00 14 1b 00 00  14 1b 00 00 04 1c 00 00 *D...............*
\end{verbatim}

\item\instructionHeader{sw\ \ \ \ rs2,imm(rs1)}
\label{insn:sw}

Set the 32-bit word of memory at the address given by the sum of \verb@rs1@ and 
\verb@imm_s@ to the 16 \acrshort{lsb}s of \verb@rs2@.

For example, given the memory contents shown in \autoref{Figure:imm:memory:dump},
if registers \verb@x13@ = \verb@0x00002650@ and \verb@x12@ = \verb@0x12345678@
then the instruction \verb@sw x12,0(x13)@ will change the memory word at address 
\verb@0x00002650@ from \verb@0x00008067@ to \verb@0x12345678@ resulting in:

\begin{verbatim}
 00002640: 6f 00 00 00 6f 00 00 00  b7 87 00 00 03 a5 07 43 *o...o..........C*
 00002650: 78 56 34 12 00 00 00 00  76 61 6c 3d 00 00 00 00 *xV4.....val=....*
 00002660: 00 00 00 00 80 84 2e 41  1f 85 45 41 80 40 9a 44 *.......A..EA.@.D*
 00002670: 4f 11 f3 c3 6e 8a 67 41  20 1b 00 00 20 1b 00 00 *O...n.gA ... ...*
 00002680: 44 1b 00 00 14 1b 00 00  14 1b 00 00 04 1c 00 00 *D...............*
\end{verbatim}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{B Type}
\label{insnformat:btype}
\DrawInsnTypeBTikz{00000000111100011000100011100011}

If \Gls{xlen}=32 then the {\em imm} value example will extracted from the instruction
and converted as shown in \autoref{Figure:imm_b_type_decode}.

\begin{figure}[ht]
\centering
\DrawInsnOpBTypeDecoding
\captionof{figure}{Decoding a B-type Instruction.}
\label{Figure:imm_b_type_decode}
\label{imm.b:decode}
\index{imm\protect\_b}
\end{figure}

\begin{itemize}
\item\instructionHeader{beq\ \ \ rs1,rs2,imm}
\label{insn:beq}

If \verb@rs1@ is equal to \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\item\instructionHeader{bge\ \ \ rs1,rs2,imm}
\label{insn:bge}

If the signed value in \verb@rs1@ is greater than or euqal to the 
signed value in \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\item\instructionHeader{bgeu\ \ \ rs1,rs2,imm}
\label{insn:bgeu}

If the unsigned value in \verb@rs1@ is greater than or euqal to the 
unsigned value in \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\item\instructionHeader{blt\ \ \ rs1,rs2,imm}
\label{insn:blt}

If the signed value in \verb@rs1@ is less than the 
signed value in \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\item\instructionHeader{bltu\ \ \ rs1,rs2,imm}
\label{insn:bltu}

If the unsigned value in \verb@rs1@ is less than the 
unsigned value in \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\item\instructionHeader{bne\ \ \ rs1,rs2,imm}
\label{insn:bne}

If \verb@rs1@ is not equal to \verb@rs2@ then add \verb@imm_b@ to the 
\verb@pc@ register.

\end{itemize}

%\label{insn:bgt}
%\label{insn:ble}
%\label{insn:bgtu}
%\label{insn:beqz}
%\label{insn:bnez}
%\label{insn:blez}
%\label{insn:bgez}
%\label{insn:bltz}
%\label{insn:bgtz}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{CPU Registers}
\label{cpuregs}

The registers are names x0 through x31 and have aliases suited to their 
conventional use.  The following table describes each register.  

Note 
\enote{Need to add a section that discusses the calling conventions}  
that the calling calling convention specifies that only some 
of the registers are to be saved by functions if they alter their contents.
The idea being that accessing memory is time-consuming and that by
classifying some registers as ``temporary'' (not saved by any function
that alter its contents) it is possible to carefully implement a function
with less need to store register values on the stack in order to use them
to perform the operations of the function.

The lack of grouping the temporary and saved registers is due to the
fact that the C extension %See \autoref{rv32:c}
provides access to only the first 16 registers when executing instructions 
in the compressed format.  


\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Reg	&	Alias	& Description						& Saved		\\
\hline
\hline
x0	&	zero	& Hard-wired zero					&			\\
x1	&	ra		& Return address					& 			\\
x2	&	sp		& Stack pointer						& yes		\\
x3	&	gp		& Global pointer					&			\\
x4	&	tp		& Thread pointer					&			\\
x5	&	t0		& Temporary/alternate link register	&			\\
x6	&	t1		& Temporary							&			\\
x7	&	t2		& Temporary							&			\\
x8	&	s0/fp	& Saved register/frame pointer		& yes		\\
x9	&	s1		& Saved register					& yes		\\
x10	&	a0		& Function argument/return value	& 			\\
x11	&	a1		& Function argument/return value	& 			\\
x12	&	a2		& Function argument					& 			\\
x13	&	a3		& Function argument					& 			\\
x14	&	a4		& Function argument					& 			\\
x15	&	a5		& Function argument					& 			\\
x16	&	a6		& Function argument					& 			\\
x17	&	a7		& Function argument					& 			\\
x18	&	s2		& Saved register					& yes		\\
x19	&	s3		& Saved register					& yes		\\
x20	&	s4		& Saved register					& yes		\\
x21	&	s5		& Saved register					& yes		\\
x22	&	s6		& Saved register					& yes		\\
x23	&	s7		& Saved register					& yes		\\
x24	&	s8		& Saved register					& yes		\\
x25	&	s9		& Saved register					& yes		\\
x26	&	s10		& Saved register					& yes		\\
x27	&	s11		& Saved register					& yes		\\
x28	&	t3		& Temporary							&			\\
x29	&	t4		& Temporary							&			\\
x30	&	t5		& Temporary							&			\\
x31	&	t6		& Temporary							&			\\
\hline
\end{tabular}
\end{center}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{memory}

Note that RISC-V is a little-endian machine.  

All instructions must be naturally aligned to their 4-byte 
boundaries.~\cite[p.~5]{rvismv1v22:2017}

If a RISC-V processor implements the C (compressed) extension then 
instructions may be aligned to 2-byte 
boundaries.\cite[p.~68]{rvismv1v22:2017}

Data alignment is not necessary but unaligned data can be inefficient.  
Accessing unaligned data using any of the load or store instructions can 
also prevent a memory access from operating 
atomically.~\cite[p.19]{rvismv1v22:2017}  See also \autoref{RV32A}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{RV32I Base Instruction Set}
\index{RV32I}

\enote{Migrate all te details into the programming chapter and
reduce this section to the obligatory reference chapter.}%
\Gls{rv32}I refers to the basic 32-bit integer instructions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LUI rd, imm}
\index{Instruction!LUI}

Load Upper Immediate.

\verb@rd@ $\leftarrow$ \verb@zr(imm)@

Copy the immediate value into bits 31:12 of the destination register and
place zeros into bits 11:0.
When XLEN is 64 or 128, the immediate value is sign-extended to the left.

\input{insn/lui.tex}


%Instruction Format and Example:
%
%\DrawInsnTypeUPicture{LUI t0, 3}{00000000000000000011001010110111}
%
%\begin{verbatim}
%00010074: 000032b7  lui     x5, 0x3         // x5 = 0x3000
% reg  0: 00000000 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 00003000 f0f0f0f0 f0f0f0f0
% reg  8: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
% reg 16: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
% reg 24: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
%     pc: 00010078
%\end{verbatim}
%
%\DrawInsnTypeUPicture{LUI t0, 0xfffff}{11111111111111111111001010110111}
%
%\begin{verbatim}
%00010078: fffff2b7  lui     x5, 0xfffff         // x5 = 0xfffff000
% reg  0: 00000000 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 fffff000 f0f0f0f0 f0f0f0f0
% reg  8: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
% reg 16: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
% reg 24: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
%     pc: 0001007c
%\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{AUIPC rd, imm}
\index{Instruction!AUIPC}

Add Upper Immediate to PC.

\verb@rd@ $\leftarrow$ \verb@pc + zr(imm)@

Create a signed 32-bit value by zero-extending imm[31:12] to the 
right (see \autoref{extension:zr}) and add this value to the 
\reg{pc} register, placing the result into \reg{rd}.

When XLEN is 64 or 128, the immediate value is also sign-extended 
to the left prior to being added to the \reg{pc} register.

\DrawInsnTypeUPicture{AUIPC t0, 3}{00000000000000000011001010110111}
\begin{verbatim}
0001007c: 00003297  auipc   x5, 0x3          // x5 = 0x1307c = 0x1007c + 0x3000
 reg  0: 00000000 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 0001307c f0f0f0f0 f0f0f0f0
 reg  8: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
 reg 16: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
 reg 24: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
     pc: 00010080
\end{verbatim}

\DrawInsnTypeUPicture{AUIPC t0, 0x81000}{10000001000000000000001010110111}
\begin{verbatim}
00010080: 81000297  auipc   x5, 0x81000          // x5 = 0x81010080 = 0x10080 + 0x81000000
 reg  0: 00000000 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 81010080 f0f0f0f0 f0f0f0f0
 reg  8: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
 reg 16: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
 reg 24: f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0-f0f0f0f0 f0f0f0f0 f0f0f0f0 f0f0f0f0
     pc: 00010084
\end{verbatim}


The AUIPC instruction supports two-instruction sequences to access arbitrary 
offsets from the PC for both control-flow transfers and data accesses. 
The combination of an AUIPC and the 12-bit immediate in a JALR can transfer 
control to any 32-bit PC-relative address, while an AUIPC plus the 12-bit 
immediate offset in regular load or store instructions can access any 32-bit 
PC-relative data address.~\cite[p.~14]{rvismv1v22:2017}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{JAL rd, imm}
\index{Instruction!JAL}

Jump and link.

\verb@rd@ $\leftarrow$ \verb@pc + 4@\\
\verb@pc@ $\leftarrow$ \verb@pc + sx(imm<<1)@

This instruction saves the address of the next instruction
that would otherwise execute (located at \reg{pc}+4) into 
\reg{rd} and then adds immediate value to the \reg{pc} causing
an unconditional branch to take place.

The standard software conventions for calling subroutines
use \reg{x1} as the return address (\reg{rd} register in this 
case).~\cite[p.~16]{rvismv1v22:2017}


Encoding:

\DrawInsnTypeJPicture{JAL x7, .+16}{00000001000000000000001111101111}

imm demultiplexed value = $00000000000000001000_2 \ll 1 = 16_{10}$


State of registers before execution:

pc = 0x11114444

State of registers after execution:

pc = 0x11114454
x7 = 0x11114448

JAL provides a method to call a subroutine using a pc-relative address.


\DrawInsnTypeJPicture{JAL x7, .-16}{11111111000111111111001111101111}

imm demultiplexed value = $11111111111111111000_2 \ll 1 = -16_{10}$

State of registers before execution:

pc = 0x11114444

State of registers after execution:

pc = 0x11114434
x7 = 0x11114448


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{JALR rd, rs1, imm}
\index{Instruction!JALR}

Jump and link register.

\verb@rd@ $\leftarrow$ \verb@pc + 4@\\
\verb@pc@ $\leftarrow$ \verb@(rs1 + sx(imm)) & ~1@

This instruction saves the address of the next instruction
that would otherwise execute (located at \reg{pc}+4) into 
\reg{rd} and then adds the immediate value to the \reg{rs1} 
register and stores the sum into the \reg{pc} register causing
an unconditional branch to take place.

Note that the branch target address is calculated by 
sign-extending the imm[11:0] bits from the instruction, 
adding it to the \reg{rs1} register and {\em then} the 
LSB of the sum is to zero and the result is stored into the 
\reg{pc} register.
The discarding of the LSB allows the branch to refer to any 
even address.

The standard software conventions for calling subroutines
use \reg{x1} as the return address (\reg{rd} register in this 
case).~\cite[p.~16]{rvismv1v22:2017}


Encoding:

\DrawInsnTypeIPicture{JALR x1, x7, 4}{00000000010000111000000011100111}

Before:

pc = 0x11114444\\
x7 = 0x44444444

After

pc = 0x5555888c\\
x1 = 0x11114448

JALR provides a method to call a subroutine using a base-displacement address.

\DrawInsnTypeIPicture{JALR x1, x0, 5}{00000000010100000000000011100111}

Note that the least significant bit in the result of rs1+imm is 
discarded/set to zero before the result is saved in the pc.
 
pc = 0x11114444

After

pc = 0x00000004\\
x1 = 0x11114448



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BEQ rs1, rs2, imm}
\index{Instruction!BEQ}

Branch if equal.

\verb@pc@ $\leftarrow$ \verb@(rs1 == rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BEQ x3, x15, 2064}{00000000111100011000100011100011}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $000_2$\\
rs1 = x3\\
rs2 = x15



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BNE rs1, rs2, imm}
\index{Instruction!BNE}

Branch if Not Equal.

\verb@pc@ $\leftarrow$ \verb@(rs1 != rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BNE x3, x15, 2064}{00000000111100011001100011100011}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $001_2$\\
rs1 = x3\\
rs2 = x15


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BLT rs1, rs2, imm}
\index{Instruction!BLT}

Branch if Less Than.

\verb@pc@ $\leftarrow$ \verb@(rs1 < rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BLT x3, x15, 2064}{00000000111100011100100011100011}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $100_2$\\
rs1 = x3\\
rs2 = x15



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BGE rs1, rs2, imm}
\index{Instruction!BGE}

Branch if Greater or Equal.

\verb@pc@ $\leftarrow$ \verb@(rs1 >= rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BGE x3, x15, 2064}{00000000111100011101100011100011}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $101_2$\\
rs1 = x3\\
rs2 = x15

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BLTU rs1, rs2, imm}
\index{Instruction!BLTU}

Branch if Less Than Unsigned.

\verb@pc@ $\leftarrow$ \verb@(rs1 < rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BLTU x3, x15, 2064}{00000000111100011110100011100011}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $110_2$\\
rs1 = x3\\
rs2 = x15


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{BGEU rs1, rs2, imm}
\index{Instruction!BGEU}

Branch if Greater or Equal Unsigned.

\verb@pc@ $\leftarrow$ \verb@(rs1 >= rs2) ? pc+sx(imm[12:1]<<1) : pc+4@

Encoding:

\DrawInsnTypeBPicture{BGEU x3, x15, 2064}{00000000111100011111100011100011}
\enote{use symbols in branch examples}

imm[12:1] = $010000001000_2 = 1032_{10}$\\
imm = $2064_{10}$\\
funct3 = $111_2$\\
rs1 = x3\\
rs2 = x15

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LB rd, imm(rs1)}
\index{Instruction!LB}

Load byte.

\verb@rd@ $\leftarrow$ \verb@sx(m8(rs1+sx(imm)))@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Load an 8-bit value from memory at address \verb@rs1+imm@, then 
sign-extend it to 32 bits before storing it in \verb@rd@


Encoding:

\DrawInsnTypeIPicture{LB x7, 4(x3)}{00000000010000011000001110000011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LH rd, imm(rs1)}
\index{Instruction!LH}

Load halfword.

\verb@rd@ $\leftarrow$ \verb@sx(m16(rs1+sx(imm)))@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Load a 16-bit value from memory at address \verb@rs1+imm@, then 
sign-extend it to 32 bits before storing it in \verb@rd@


Encoding:

\DrawInsnTypeIPicture{LH x7, 4(x3)}{00000000010000011001001110000011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LW rd, imm(rs1)}
\index{Instruction!LW}

Load word.

\verb@rd@ $\leftarrow$ \verb@sx(m32(rs1+sx(imm)))@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Load a 32-bit value from memory at address \verb@rs1+imm@, then 
store it in \verb@rd@

Encoding:

\DrawInsnTypeIPicture{LW x7, 4(x3)}{00000000010000011010001110000011}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LBU rd, imm(rs1)}
\index{Instruction!LBU}

Load byte unsigned.

\verb@rd@ $\leftarrow$ \verb@zx(m8(rs1+sx(imm)))@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Load an 8-bit value from memory at address \verb@rs1+imm@, then 
zero-extend it to 32 bits before storing it in \verb@rd@

Encoding:

\DrawInsnTypeIPicture{LBU x7, 4(x3)}{00000000010000011100001110000011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{LHU rd, imm(rs1)}
\index{Instruction!LHU}

Load halfword unsigned.

\verb@rd@ $\leftarrow$ \verb@zx(m16(rs1+sx(imm)))@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Load an 16-bit value from memory at address \verb@rs1+imm@, then 
zero-extend it to 32 bits before storing it in \verb@rd@

Encoding:

\DrawInsnTypeIPicture{LHU x7, 4(x3)}{00000000010000011101001110000011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SB rs2, imm(rs1)}
\index{Instruction!SB}

Store Byte.

\verb@m8(rs1+sx(imm))@ $\leftarrow$ \verb@rs2[7:0]@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Store the 8-bit value in \verb@rs2[7:0]@ into memory at 
address \verb@rs1+imm@.

Encoding:

\DrawInsnTypeSPicture{SB x3, 19(x15)}{00000000111100011000100110100011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SH rs2, imm(rs1)}
\index{Instruction!SH}

Store Halfword.

\verb@m16(rs1+sx(imm))@ $\leftarrow$ \verb@rs2[15:0]@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Store the 16-bit value in \verb@rs2[15:0]@ into memory at 
address \verb@rs1+imm@.


Encoding:

\DrawInsnTypeSPicture{SH x3, 19(x15)}{00000000111100011001100110100011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SW rs2, imm(rs1)}
\index{Instruction!SW}

Store Word

\verb@m16(rs1+sx(imm))@ $\leftarrow$ \verb@rs2[31:0]@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Store the 32-bit value in \verb@rs2@ into memory at address \verb@rs1+imm@.

Encoding:

\DrawInsnTypeSPicture{SW x3, 19(x15)}{00000000111100011010100110100011}

Show pos \& neg imm examples.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ADDI rd, rs1, imm}
\index{Instruction!ADDI}

Add Immediate

\verb@rd@ $\leftarrow$ \verb@rs1+sx(imm)@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

Encoding:

\DrawInsnTypeIPicture{ADDI x1, x7, 4}{00000000010000111000000010010011}

Before:

x7 = 0x11111111

After:

x1 = 0x11111115

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLTI rd, rs1, imm}
\index{Instruction!SLTI}

Set LessThan Immediate

\verb@rd@ $\leftarrow$ \verb@(rs1 < sx(imm)) ? 1 : 0@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

If the sign-extended immediate value is less than the value
in the \reg{rs1} register then the value 1 is stored in the 
\reg{rd} register.  Otherwise the value 0 is stored in the
\reg{rd} register. 

Encoding:

\DrawInsnTypeIPicture{SLTI x1, x7, 4}{00000000010000111010000010010011}

Before:

x7 = 0x11111111

After:

x1 = 0x00000000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLTIU rd, rs1, imm}
\index{Instruction!SLTIU}

Set LessThan Immediate Unsigned

\verb@rd@ $\leftarrow$ \verb@(rs1 < sx(imm)) ? 1 : 0@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

If the sign-extended immediate value is less than the value
in the \reg{rs1} register then the value 1 is stored in the 
\reg{rd} register.  Otherwise the value 0 is stored in the
\reg{rd} register.  Both the immediate and \reg{rs1} register
values are treated as unsigned numbers for the purposes of the 
comparison.\footnote{The immediate value is first sign-extended to
XLEN bits then treated as an unsigned number.\cite[p.~14]{rvismv1v22:2017}}


Encoding:

\DrawInsnTypeIPicture{SLTIU x1, x7, 4}{00000000010000111011000010010011}

Before:

x7 = 0x81111111

After:

x1 = 0x00000001

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{XORI rd, rs1, imm}
\index{Instruction!XORI}

Exclusive Or Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 ^ sx(imm)@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

The logical XOR of the sign-extended immediate value and the value 
in the \reg{rs1} register is stored in the \reg{rd} register.

Encoding:

\DrawInsnTypeIPicture{XORI x1, x7, 4}{00000000010000111100000010010011}

Before:

x7 = 0x81111111

After:

x1 = 0x81111115

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ORI rd, rs1, imm}
\index{Instruction!ORI}

Or Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 | sx(imm)@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

The logical OR of the sign-extended immediate value and the value 
in the \reg{rs1} register is stored in the \reg{rd} register.

Encoding:

\DrawInsnTypeIPicture{ORI x1, x7, 4}{00000000010000111110000010010011}

Before:

x7 = 0x81111111

After:

x1 = 0x81111115

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ANDI rd, rs1, imm}
\index{Instruction!ANDI}

And Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 & sx(imm)@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

The logical AND of the sign-extended immediate value and the value 
in the \reg{rs1} register is stored in the \reg{rd} register.


Encoding:

\DrawInsnTypeIPicture{ANDI x1, x7, 4}{00000000010000111111000010010011}

Before:

x7 = 0x81111111

After:

x1 = 0x81111115

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLLI rd, rs1, shamt}
\index{Instruction!SLLI}

Shift Left Logical Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 << shamt@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@


SLLI is a logical left shift operation (zeros are shifted
into the lower bits).  The value in rs1 shifted left shamt
number of bits and the result placed into rd.~\cite[p.~14]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRShiftPicture{SLLI x7, x3, 2}{00000000001000011001001110100011}

x3 = 0x81111111

After:

x7 = 0x04444444

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SRLI rd, rs1, shamt}
\index{Instruction!SRLI}

Shift Right Logical Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 >> shamt@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SRLI is a logical right shift operation (zeros are shifted
into the higher bits).  The value in rs1 shifted right shamt
number of bits and the result placed into rd.~\cite[p.~14]{rvismv1v22:2017}


Encoding:

\DrawInsnTypeRShiftPicture{SRLI x7, x3, 2}{00000000001000011101001110010011}

x3 = 0x81111111

After:

x7 = 0x20444444

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SRAI rd, rs1, shamt}
\index{Instruction!SRAI}

Shift Right Arithmetic Immediate

\verb@rd@ $\leftarrow$ \verb@rs1 >> shamt@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SRAI is a logical right shift operation (zeros are shifted
into the higher bits).  The value in rs1 shifted right shamt
number of bits and the result placed into rd.~\cite[p.~14]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRShiftPicture{SRAI x7, x3, 2}{01000000001000011101001110010011}

x3 = 0x81111111

After:

x7 = 0xe0444444


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ADD rd, rs1, rs2}
\index{Instruction!ADD}

Add 

\verb@rd@ $\leftarrow$ \verb@rs1 + rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

ADD performs addition. Overflows are ignored and the low 32 bits of 
the result are written to rd.~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{ADD x7, x3, x31}{00000001111100011000001110110011}

x3  = 0x81111111
x31 = 0x22222222

After:

x7 = 0xa3333333

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SUB rd, rs1, rs2}
\index{Instruction!SUB}

Subtract

\verb@rd@ $\leftarrow$ \verb@rs1 - rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SUB performs subtraction. Underflows are ignored and the low 32 bits of 
the result are written to rd.~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SUB x7, x3, x31}{01000001111100011000001110110011}

x3  = 0x83333333
x31 = 0x01111111

After:

x7 = 0x82222222


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLL rd, rs1, rs2}
\index{Instruction!SLL}

Shift Left Logical

\verb@rd@ $\leftarrow$ \verb@rs1 << rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SLL performs a logical left shift on the value in register rs1 by 
the shift amount held in the lower 5 bits of register rs2.~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SLL x7, x3, x31}{00000001111100011001001110110011}

x3  = 0x83333333\\
x31 = 0x00000002

After:

x7 = 0x0ccccccc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLT rd, rs1, rs2}
\index{Instruction!SLT}

Set Less Than

\verb@rd@ $\leftarrow$ \verb@(rs1 < rs2) ? 1 : 0@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SLT performs a signed compare, writing 1 to \reg{rd} if \reg{rs1} $<$ \reg{rs2}, 0 
otherwise.~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SLT x7, x3, x31}{00000001111100011010001110110011}

x3  = 0x83333333\\
x31 = 0x00000002

After:

x7 = 0x00000001

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SLTU rd, rs1, rs2}
\index{Instruction!SLTU}

Set Less Than Unsigned 

\verb@rd@ $\leftarrow$ \verb@(rs1 < rs2) ? 1 : 0@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SLTU performs an unsigned compare, writing 1 to \reg{rd} if \reg{rs1} $<$ \reg{rs2}, 0 otherwise. 
Note, SLTU rd, x0, rs2 sets \reg{rd} to 1 if \reg{rs2} is not equal to zero, otherwise 
sets \reg{rd} to zero (assembler pseudo-op \verb@SNEZ rd, rs@).~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SLTU x7, x3, x31}{00000001111100011011001110110011}

x3  = 0x83333333\\
x31 = 0x00000002

After:

x7 = 0x00000000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{XOR rd, rs1, rs2}
\index{Instruction!XOR}

Exclusive Or

\verb@rd@ $\leftarrow$ \verb@rs1 ^ rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

XOR performs a bit-wise exclusive or on rs1 and rs2.  
The result is stored on rd.

Encoding:

\DrawInsnTypeRPicture{XOR x7, x3, x31}{00000001111100011100001110110011}

x3  = 0x83333333\\
x31 = 0x1888ffff

After:

x7 = 0x9bbbcccc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SRL rd, rs1, rs2}
\index{Instruction!SRL}

Shift Right Logical

\verb@rd@ $\leftarrow$ \verb@rs1 >> rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SRL performs a logical right shift on the value in register rs1 by 
the shift amount held in the lower 5 bits of 
register rs2.~\cite[p.~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SRL x7, x3, x31}{00000001111100011101001110110011}

x3  = 0x83333333\\
x31 = 0x00000010

After:

x7 = 0x00008333

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SRA rd, rs1, rs2}
\index{Instruction!SRA}

Shift Right Arithmetic

\verb@rd@ $\leftarrow$ \verb@rs1 >> rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

SRA performs an arithmetic right shift (the original sign bit is copied 
into the vacated upper bits) on the value in register rs1 by the shift 
amount held in the lower 5 bits of 
register rs2.~\cite[p.~14,~15]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{SRA x7, x3, x31}{01000001111100011101001110110011}

x3  = 0x83333333\\
x31 = 0x00000010

After:

x7 = 0xffff8333

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{OR rd, rs1, rs2}
\index{Instruction!OR}

Or 

\verb@rd@ $\leftarrow$ \verb@rs1 | rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

OR is a logical operation that performs a bit-wise OR on 
register rs1 and rs2 and then places the result 
in rd.~\cite[p.~14]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{OR x7, x3, x31}{00000001111100011101001110110011}

x3  = 0x83333333\\
x31 = 0x00000440

After:

x7 = 0x83333773

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{AND rd, rs1, rs2}
\index{Instruction!AND}

And

\verb@rd@ $\leftarrow$ \verb@rs1 & rs2@\\
\verb@pc@ $\leftarrow$ \verb@pc+4@

AND is a logical operation that performs a bit-wise AND on 
register rs1 and rs2 and then places the result 
in rd.~\cite[p.~14]{rvismv1v22:2017}

Encoding:

\DrawInsnTypeRPicture{AND x7, x3, x31}{00000001111100011110001110110011}

x3  = 0x83333333\\
x31 = 0x00000fe2

After:

x7 = 0x00000322

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FENCE predecessor, successor}
\index{Instruction!FENCE}

\enote{Which of the i, o, r and w goes into each bit?  See what gas does.}%
The FENCE instruction is used to order device I/O and memory accesses as 
viewed by other RISC-V harts and external devices or co-processors. Any 
combination of device input (I), device output (O), memory reads (R), 
and memory writes (W) may be ordered with respect to any combination
of the same. Informally, no other RISC-V hart or external device can 
observe any operation in the successor set following a FENCE before any 
operation in the predecessor set preceding the FENCE. The execution 
environment will define what I/O operations are possible, and in particular, 
which load and store instructions might be treated and ordered as device 
input and device output operations respectively rather than memory reads 
and writes. For example, memory-mapped I/O devices will typically be 
accessed with uncached loads and stores that are ordered using the I and O
 bits rather than the R and W bits. Instruction-set extensions might 
also describe new coprocessor I/O instructions that will also be ordered 
using the I and O bits in a FENCE.~\cite[p.~21]{rvismv1v22:2017}

Operation:

\verb@pc@ $\leftarrow$ \verb@pc+4@

Encoding:

\DrawInsnTypeFPicture{FENCE iorw, iorw}{00001111111100000000000000001111}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FENCE.I}
\index{Instruction!FENCE.I}

The FENCE.I instruction is used to synchronize the instruction and 
data streams. RISC-V does not guarantee that stores to instruction 
memory will be made visible to instruction fetches on the same
RISC-V hart until a FENCE.I instruction is executed. A FENCE.I 
instruction only ensures that a subsequent instruction fetch on 
a RISC-V hart will see any previous data stores already visible to 
the same RISC-V hart. FENCE.I does not ensure that other RISC-V harts' 
instruction fetches will observe the local hart's stores in a 
multiprocessor system. To make a store to instruction memory
visible to all RISC-V harts, the writing hart has to execute a 
data FENCE before requesting that all remote RISC-V harts execute 
a FENCE.I.~\cite[p.~21]{rvismv1v22:2017}

Operation:

\verb@pc@ $\leftarrow$ \verb@pc+4@

Encoding:

\DrawInsnTypeFPicture{FENCE.I}{00000000000000000001000000001111}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ECALL}
\index{Instruction!ECALL}

The ECALL instruction is used to make a request to the supporting 
execution environment, which is usually an operating system. The ABI 
for the system will define how parameters for the environment
request are passed, but usually these will be in defined locations 
in the integer register file.~\cite[p.~24]{rvismv1v22:2017}

\DrawInsnTypeEPicture{ECALL}{00000000000000000000000001110011}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{EBREAK}
\index{Instruction!EBREAK}

The EBREAK instruction is used by debuggers to cause control to be 
transferred back to a debugging environment.~\cite[p.~24]{rvismv1v22:2017}

\DrawInsnTypeEPicture{EBREAK}{00000000000100000000000001110011}


