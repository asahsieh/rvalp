\chapter{Numbers and Storage Systems}
\label{chapter:numbers}

This chapter discusses how data are represented and stored in a computer.

In the context of computing, {\em boolean} refers to a condition that can 
be either true and false and {\em binary} refers to the use of a base-2 
numeric system to rpresent numbers.

RISC-V assembly language uses binary to represent all values, be they 
boolean or numeric.  It is the context within which they are used that
determines whether they are boolean or numeric.

RISC-V assembly language uses zero to represent {\em false} and one 
to represent {\em true}.  In general, however, it is useful to relax 
this and define zero {\bf and only zero} to be {\em false} and anything 
that is not {\em false} is therefore {\em true}.%
\footnote{This is how {\em true} and {\em false} behave in C, C++, and
many other languages as well as the common assembly language idioms
discussed in this text.}

\enote{Add some diagrams here showing bits, bytes and the MSB, 
LSB,\ldots\ perhaps relocated from the RV32I chapter?}%
The reason for this relaxation is because, while a single binary digit 
(\gls{bit}) can represent the two values zero and one, the vast majority 
of the time data is processed by the CPU in groups of bits.  These
groups have names like \gls{byte}, \gls{halfword} and \gls{fullword}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Boolean Functions}

\enote{Probably should add basic truth table diagrams.}%
Boolean functions apply on a per-bit basis.
%in that they do not impact neighboring bits.
%by generating things like a carry or a borrow.
When applied to multi-bit values, each bit position is operated upon 
independently of the other bits.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{NOT}

The {\em NOT} operator applies to a single operand and represents the 
opposite of the input.
\enote{Need to define unary, binary and ternary operators without 
confusing binary operators with binary numbers.}

If the input is 1 then the output is 0.  If the input is 0 then the
output is 1.  In other words, the output value is {\em not} that of the 
input value.

This text will use the operator used in the C language when discussing 
the {\em NOT} operator in symbolic form.  Specifically the tilde: `\verb@~@'.

\begin{verbatim}
  ~ 1 1 1 1 0 1 0 1  <== A
  -----------------
    0 0 0 0 1 0 1 0  <== output
\end{verbatim}

In a line of code the above might read like this: \verb@output = ~A@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{AND}

The boolean {\em and} function has two or more inputs and the output is a
single bit.  The output is 1 if and only if all of the input values are 1.
Otherwise it is 0.

This text will use the operator used in the C language when discussing 
the {\em AND} operator in symbolic form.  Specifically the ampersand: `\verb@&@'.

This function works like it does in spoken language.  For example
if A is 1 {\em AND} B is 1 then the output is 1 (true).
Otherwise the output is 0 (false).  For example:

\begin{verbatim}
    1 1 1 1 0 1 0 1  <== A
  & 1 0 0 1 0 0 1 1  <== B
  -----------------
    1 0 0 1 0 0 0 1  <== output
\end{verbatim}

In a line of code the above might read like this: \verb@output = A & B@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{OR}

The boolean {\em or} function has two or more inputs and the output is a
single bit.  The output is 1 if at least one of the input values are 1.

This text will use the operator used in the C language when discussing
the {\em OR}  operator in symbolic form.  Specifically the pipe: `\verb@|@'.

This function works like it does in spoken language.  For example
if A is 1 {\em OR} B is 1 then the output is 1 (true).
Otherwise the output is 0 (false).  For example:

\begin{verbatim}
    1 1 1 1 0 1 0 1  <== A
  | 1 0 0 1 0 0 1 1  <== B
  -----------------
    1 1 1 1 0 1 1 1  <== output
\end{verbatim}

In a line of code the above might read like this: \verb@output = A | B@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{XOR}

The boolean {\em exclusive or} function has two or more inputs and the 
output is a single bit.  The output is 1 if only an odd number of inputs 
are 1. Otherwise the output will be 0.

This text will use the operator used in the C language when discussing
the {\em XOR}  operator in symbolic form.  Specifically the carrot: `\verb@^@'.

Note that when {\em XOR} is used with two inputs, the output
is set to 1 (true) when the inputs have different values and 0 
(false) when the inputs both have the same value.

For example:

\begin{verbatim}
    1 1 1 1 0 1 0 1  <== A
  ^ 1 0 0 1 0 0 1 1  <== B
  -----------------
    0 1 1 0 0 1 1 0  <== output
\end{verbatim}

In a line of code the above might read like this: \verb@output = A ^ B@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integers and Counting}

A binary integer is constructed with only 1s and 0s in the same
manner as decimal numbers are constructed with values from 0 to 9.

Counting in binary (base-2) uses the same basic rules as decimal (base-10).  
The difference comes in when we consider that there are ten decimal digits and 
only two binary digits.  Therefore, in base-10, we must carry when adding one to 
nine (because there is no digit representing a ten) and, in base-2, we must 
carry when adding one to one (because there is no digit representing a two.)

\autoref{Figure:integers} shows an abridged table of the decimal, binary and hexadecimal 
values ranging from $0_{10}$ to $129_{10}$.

\begin{figure}[t]
\begin{center}
\begin{tabular}{|c|c|c||c|c|c|c|c|c|c|c||c|c|}
\hline
\multicolumn{3}{|c||}{Decimal} & \multicolumn{8}{|c||}{Binary} & \multicolumn{2}{|c|}{Hex}\\
\hline
$10^2$	& $10^1$	& $10^0$	& $2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$		& $16^1$ & $16^0$	\\
\hline
100		&	10		& 1			& 128	& 64	& 32	& 16	& 8		& 4		& 2		& 1			& 16	& 1			\\
\hline \hline
0		&	0		&	0		& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0		& 0 & 0 \\
0		&	0		&	1		& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1		& 0 & 1 \\
0		&	0		&	2		& 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0		& 0 & 2 \\
0		&	0		&	3		& 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1		& 0 & 3 \\
0		&	0		&	4		& 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0		& 0 & 4 \\
0		&	0		&	5		& 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1		& 0 & 5 \\
0		&	0		&	6		& 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0		& 0 & 6 \\
0		&	0		&	7		& 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1		& 0 & 7 \\
0		&	0		&	8		& 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0		& 0 & 8 \\
0		&	0		&	9		& 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1		& 0 & 9 \\
0		&	1		&	0		& 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0		& 0 & a \\
0		&	1		&	1		& 0 & 0 & 0 & 0 & 1 & 0 & 1 & 1		& 0 & b \\
0		&	1		&	2		& 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0		& 0 & c \\
0		&	1		&	3		& 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1		& 0 & d \\
0		&	1		&	4		& 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0		& 0 & e \\
0		&	1		&	5		& 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1		& 0 & f \\
0		&	1		&	6		& 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0		& 1 & 0 \\
0		&	1		&	7		& 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1		& 1 & 1 \\
\hline
\multicolumn{3}{|c||}{\ldots} & \multicolumn{8}{|c||}{\ldots} & \multicolumn{2}{|c|}{\ldots}\\
\hline
1       &   2       &   5		& 0 & 1 & 1 & 1 & 1 & 1 & 0 & 1		& 7 & d \\
1       &   2       &   6		& 0 & 1 & 1 & 1 & 1 & 1 & 1 & 0		& 7 & e \\
1       &   2       &   7		& 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1		& 7 & f \\
1       &   2       &   8		& 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0		& 8 & 0 \\
\hline
\end{tabular}
\end{center}
\captionof{figure}{Counting in decimal, binary and hexadecimal.}
\label{Figure:integers}
\end{figure}

One way to look at this table is on a per-row basis where each place 
value is represented by the base raised to the power of the place value
position (shown in the column headings.)  This is useful when
converting arbitrary values between bases.  For example to interpret
the decimal value on the fourth row: 

\begin{equation}
0 \times 10^2 + 0 \times 10^1 + 3 \times 10^0 = 3_{10}
\end{equation}

Interpreting the binary value on the fourth row by converting it to decimal:

\begin{equation}
0 \times 2^7 + 0 \times 2^6 +0 \times 2^5 +0 \times 2^4 +0 \times 2^3 +0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 3_{10}
\end{equation}

Interpreting the hexadecimal value on the fourth row by converting it to decimal:

\begin{equation}
0 \times 16^1 + 3 \times 16^0 = 3_{10}
\end{equation}


Another way to look at this table is on a per-column basis.  When
tasked with drawing such a table by hand, it might be useful 
to observe that, just as in decimal, the right-most column will
cycle through all of the values represented in the chosen base
then cycle back to zero and repeat.  (For example, in binary this
pattern is 0-1-0-1-0-1-0-\ldots) The next column in each base
will cycle in the same manner except each of the values is repeated
as many times as is represented by the place value (in the case of 
decimal, $10^1$ times, binary $2^1$ times, hex $16^1$ times.  Again,
the for binary numbers this pattern is  0-0-1-1-0-0-1-1-\ldots)
This continues for as many columns as are needed to represent the 
magnitude of the desired number.

Another item worth noting is that any even binary number will always
have a 0 LSB and odd numbers will always have a 1 LSB.

As is customary in decimal, leading zeros are sometimes not shown 
for readability.

The relationship between binary and hex values is also worth taking
note.  Because $2^4 = 16$, there is a clean and simple grouping
of 4 \gls{bit}s to 1 \gls{hit}.  There is no such relationship
between binary and decimal.  

Writing and reading numbers in binary that are longer than 8 bits 
is cumbersome and prone to error.  The simple conversion between 
binary and hex makes hex a convenient shorthand for expressing 
binary values in many situations.  

For example, consider the following value expressed in binary, 
hexadecimal and decimal (spaced to show the relationship
between binary and hex):

\begin{verbatim}
Binary value:       0010 0111 1011 1010 1100 1100 1111 0101
Hex Value:             2    7    B    A    C    C    F    5
Decimal Value:                                    666553589
\end{verbatim}

Empirically we can see that grouping the bits into sets of four
allows an easy conversion to hex and expressing it as such is
$\frac{1}{4}$ as long as in binary while at the same time
allowing for easy conversion back to binary.

The decimal value in this example does not easily convey a sense
of the binary value.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Converting Between Bases}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{From Binary to Decimal}
\label{section:bindec}

Alas, it is occasionally necessary to convert between decimal,
binary and/or hex.

To convert from binary to decimal, put the decimal value of the place values 
{\ldots8 4 2 1} over the binary digits like this:

\begin{verbatim}
    128 64 32 16  8  4  2  1
      0  0  0  1  1  0  1  1
\end{verbatim}

Now sum the place-values that are expressed in decimal for each 
bit with the value of 1: $16+8+2+1$.  The integer binary value
$00011011_2$ represents the decimal value $27_{10}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{From Binary to Hexadecimal}
\label{section:binhex}

Conversion from binary to hex involves grouping the bits into
sets of four and then performing the same summing process as 
shown above.  If there is not a multiple of four bits then
extend the binary to the left with zeros to make it so.

Grouping the bits into sets of four and summing:

\begin{verbatim}
Place:         8 4 2 1     8 4 2 1     8 4 2 1     8 4 2 1
Binary:        0 1 1 0     1 1 0 1     1 0 1 0     1 1 1 0
Decimal:         4+2  =6   8+4+  1=13  8+  2  =10  8+4+2  =14
\end{verbatim}

After the summing, convert each decimal value to hex.  The decimal
values from 0--9 are the same values in hex.  Because we don't have any
more numerals to represent the values from 10-15, we use the first 6
letters (See the right-most column of \autoref{Figure:integers}.)
Fortunately there are only six hex mappings involving letters.  Thus 
it is reasonable to memorize them.

Continuing this example:

\begin{verbatim}
Decimal:               6           13          10          14
Hex:                   6           D           A           E
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{From Hexadecimal to Binary}

Again, the four-bit mapping between binary and hex makes this
task as straight forward as using a look-up table.

For each \gls{hit} (Hex digIT), translate it to its unique four-bit pattern.
Perform this task either by memorizing each of the 16 patterns 
or by converting each hit to decimal first and then converting
each four-bit binary value to decimal using the place-value summing 
method discussed in \autoref{section:bindec}.

For example:

\begin{verbatim}
Hex:           4            C
Binary:        0  1  0  0   1 1 0 0
Decimal:     128 64 32 16   8 4 2 1
Sum:             64+        8+4       = 76
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{From Decimal to Binary}

To convert arbitrary decimal numbers to binary, extend the list 
of binary place values until it exceeds the value of the decimal 
number being converted.  Then make successive subtractions of each 
of the place values that would yield a non-negative result.

For example, to convert $1234_{10}$ to binary:

\begin{verbatim}
Place values: 2048-1024-512-256-128-64-32-16-8-4-2-1

   0          2048      (too big)
   1   1234 - 1024 = 210
   0          512       (too big)
   0          256       (too big)
   1    210 - 128  = 82
   1     82 - 64   = 18
   0          32        (too big)
   1     18 - 16   = 2
   0          8         (too big)
   0          4         (too big)
   1      2 - 2    = 0
   0          1         (too big)
\end{verbatim}

The answer using this notation is listed vertically
in the left column with the \acrshort{msb} on the top and 
the \acrshort{lsb} on the bottom line: $010011010010_2$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{From Decimal to Hex}

Conversion from decimal to hex can be done by using the place
values for base-16 and the same math as from decimal to binary
or by first converting the decimal value to binary and then
from binary to hex by using the methods discussed above.

Because binary and hex are so closely related, performing
a conversion by way of binary is quite straight forward.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Addition of Binary Numbers}

The addition of binary numbers can be performed long-hand the
same way decimal addition is taught in grade school.  In fact binary
addition is easier since it only involves adding 0 or 1.

The first thing to note that in any number base $0+0=0$, $0+1=1$, and 
$1+0=1$.  Since there is no ``two'' in binary (just like there is 
no ``ten'' decimal) adding $1+1$ results in a zero with a carry as
in: $1+1=10_2$ and in: $1+1+1=11_2$.  Using these five sums, any two
binary integers can be added.

For example:

\begin{verbatim}
        111111  1111  <== carries
     0110101111001111 <== addend
   + 0000011101100011 <== addend
   ------------------
     0111001100110010 <== sum
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Signed Numbers}

There are multiple methods used to represent signed binary integers.
The method used by most modern computers is called ``two's complement.''

A two's complement number is encoded in such a manner as to simplify
the hardware used to add, subtract and compare integers.  

A simple method of thinking about two's complement numbers is to
negate the place value of the \acrshort{msb}.  For example, the 
number one is represented the same as discussed before:

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      0  0  0  0  0  0  0  1
\end{verbatim}

The \acrshort{msb} of any negative number in this format will always
be 1.  For example the value $-1_{10}$ is:

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      1  1  1  1  1  1  1  1
\end{verbatim}

\ldots because: $-128+64+32+16+8+4+2+1=-1$.

This format has the virtue of allowing the same addition logic 
discussed above to be used to calculate $-1+1=0$.

\begin{verbatim}
   -128 64 32 16  8  4  2  1 <== place value
   1  1  1  1  1  1  1  1  0 <== carries
      1  1  1  1  1  1  1  1 <== addend (-1)
    + 0  0  0  0  0  0  0  1 <== addend (1)
      ----------------------
   1  0  0  0  0  0  0  0  0 <== sum (0 with an overflow)
\end{verbatim}

In order for this to work, the \gls{overflow} carry out of the 
sum of the MSBs is ignored.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Converting between Positive and Negative}

Changing the sign on two's complement numbers can be described as
inverting all of the bits (which is also known as the one's complement)
and then add one.

For example, inverting the number {\em four}:

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      0  0  0  0  0  1  0  0 <== 4

                     1  1    <== carries
      1  1  1  1  1  0  1  1 <== one's complement of 4
    + 0  0  0  0  0  0  0  1 <== plus 1
      ----------------------
      1  1  1  1  1  1  0  0 <== -4
\end{verbatim}

This can be verified by adding 5 to the result and observe that
the sum is 1:

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      1  1  1  1  1          <== carries
      1  1  1  1  1  1  0  0 <== -4
    + 0  0  0  0  0  1  0  1 <== 5
      ----------------------
   1  0  0  0  0  0  0  0  1
\end{verbatim}

Note that the changing of the sign using this method is symmetric
in that it is identical when converting from negative to positive
and when converting from positive to negative: flip the bits and
add 1.

For example, changing the value -4 to 4 to illustrate the
reverse of the conversion above:

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      1  1  1  1  1  1  0  0 <== -4

                     1  1    <== carries
      0  0  0  0  0  0  1  1 <== one's complement of -4
    + 0  0  0  0  0  0  0  1 <== plus 1
      ----------------------
      0  0  0  0  0  1  0  0 <== 4
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtraction of Binary Numbers}


Subtraction of binary numbers is performed by first negating
the subtrahend and then adding the two numbers.  Due to the
nature of two's complement numbers this will work for both 
signed and unsigned numbers.
\enote{This section needs more examples of subtracting 
signed an unsigned numbers and a discussion on how 
signedness is not relevant until the results are interpreted. 
For example adding $-4+ -8=-12$ using two 8-bit numbers 
is the same as adding $252+248=500$ and truncating the result 
to 244.}

To calculate $-4-8 = -12$

\begin{verbatim}
   -128 64 32 16  8  4  2  1
      1  1  1  1  1  1  0  0 <== -4
    - 0  0  0  0  1  0  0  0 <== 8


                  1  1  1    <== carries
      1  1  1  1  0  1  1  1 <== one's complement of -8
    + 0  0  0  0  0  0  0  1 <== plus 1
      ----------------------
      1  1  1  1  1  0  0  0 <== -8
      
	  
      1  1  1  1             <== carries
      1  1  1  1  1  1  0  0 <== -4
    + 1  1  1  1  1  0  0  0 <== -8
      ----------------------
   1  1  1  1  1  0  1  0  0 < == -12
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Truncation and Overflow}

Discuss the details of truncation and overflow here.
\enote{This chapter should be made consistent in its use of 
{\em truncation} and {\em overflow} as occur with signed and unsigned
addition and subtraction.}

I prefer to define {\em truncation} as the loss of data as result of 
the bit-length of the destination being too small to hold result of an 
operation and {\em overflow} as when the carry into a sign bit is not 
the same as the carry out of the sign bit.

Where addition and subtraction on the RV32 is concerned, the sum or difference of 
two unsigned 32-bit numbers will be {\em truncated} when the operation results in 
a carry out of bit 31.  Unsinged operations can not overflow (as defined above).

(show a truncation picture here)

An Overflow occurs with signed numbers when the two addends are positive and 
sum is negative or the addends are both negative and the sum is positive.

(show an overflow picture here)

(show mixed overflow and truncation situations here to drive home the need
to ignore truncation when dealing with signed numbers.)

0xffffffff + 0x00000002 has truncation but not overflow 
(OK for signed, not OK for unsigned).

0xffffffff + 0xfffffffe also has truncation but not overflow.

0x40000000 + 0x40000000 has overflow but not truncation. (We care if are signed numbers.)

0x80000000 + 0x80000000 has both overflow and truncation. (we care regardless of signedness)

Where subtraction is concerned the notion of a borrow is the same as carry.


\enote{I think that overloading the word {\em overflow} like this can be is 
confusing to new programmers.}%
Page 13 of~\cite{rvismv1v22:2017} mixes these two notions of 
(and never mentions the word {\em truncate}) like this:
\begin{quote}
We did not include special instruction set support for overflow checks on 
integer arithmetic operations in the base instruction set, as many overflow 
checks can be cheaply implemented using RISC-V branches. Overflow checking for 
unsigned addition requires only a single additional branch instruction after the 
addition: \verb@add t0, t1, t2; bltu t0, t1, overflow@.  

For signed addition, if one operand's sign is known, overflow checking requires 
only a single branch after the addition: 
\verb@addi t0, t1, +imm; blt t0, t1, overflow@. This covers the common 
case of addition with an immediate operand.

For general signed addition, three additional instructions after the addition 
are required, leveraging the observation that the sum should be less than one 
of the operands if and only if the other operand is negative.
\begin{verbatim}
add t0, t1, t2
slti t3, t2, 0
slt t4, t0, t1
bne t3, t4, overflow
\end{verbatim}
In RV64, checks of 32-bit signed additions can be optimized further by comparing 
the results of ADD and ADDW on the operands.
\end{quote}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sign and Zero Extension}

\enote{Refactor the sx() and zx() discussion in the RV32I chapter 
and locate the details here.}%
Seems like a good place to discuss extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shifting}

Seems like a good place to discuss logical and arithmetic shifting.

shift left logical

shift right logical

shift right arithmetic


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Main Memory Storage}

\enote{Consider refactoring the memory discussion in RV32 reference chapter
and placing some of it in this section.}%
When transferring data between its registers registers and main memory a
RISC-V system uses the little-endian byte order.\footnote{
See\cite{IEN137} for some history of the big/little-endian ``controversy.''}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Memory Dump}

Introduce the memory dump and how to read them here.

\listing{rvddt_memdump.out}{{\tt rvddt} memory dump}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Big Endian Representation}

Using the memory dump contents in prior section, discuss how 
big endian values are stored.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Little Endian Representation}

Using the memory dump contents in prior section, discuss how 
little endian values are stored.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Character Strings and Arrays}

Define character strings and arrays.

Using the prior memory dump, discuss how and where things are stored and
retrieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Context is Important!}

Data values can be interpreted differently depending on the context in 
which they are used.  Assuming what a set of bytes is used for based on 
their contents can be very misleading!  For example, there is a 0x76 at 
address 0x00002658.  This is a `v' is you use it as an ASCII 
(see~\autoref{chapter:ascii}) character, a $118_{10}$ if it is an integer 
value and TRUE if it is a conditional.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alignment}

Draw a diagram showing the overlapping data types when they are all aligned.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Instruction Alignment}

\enote{Rewrite this section for data rather than instructions and then
note here that instructions must be naturally aligned.  For RV32 that
is on a 4-byte boundary}%
Every possible instruction that an RV32I CPU can execute contains
exactly 32 bits.  Therefore each one must be stored in four bytes 
of the main memory.

To simplify the hardware, each instruction must be placed into four 
adjacent bytes whose numeric address sequence begins with a multiple 
four.  For example, an instruction might be located in bytes 
4, 5, 6 and 7 (but not in 5, 6, 7 and 8 nor in 9, 3, 1, and 0\ldots).

This sort of addressing requirement is common and is referred to as
\gls{alignment}.  An aligned instruction begins at a memory address
that is a multiple of four.  An {\em unaligned} instruction would
be one beginning at any other address and is {\em illegal}.

An attempt to fetch an instruction from an unaligned address
will result in an error referred to as an alignment {\em \gls{exception}}.
This and other exceptions cause the CPU to stop executing the
current instruction and start executing a different set of instructions
that are prepared to handle the problem.  Often an exception is
handled by completely stopping the program in a way that is commonly
referred to as a system or application {\em crash}.

Given a properly aligned instruction address, the CPU can request
that the main memory locate and deliver the values of the four bytes
in the address sequence to the CPU using what is called a memory
read operation.  Some systems can deliver four (or more) bytes at the
same time while others might only be capable of delivering one or
two bytes at a time.  These differences in hardware typically impact the
cost and performance of a system.\footnote{The design and implementation
choices that determine how any given system operates are part of what is
called a system's {\em organization} and is beyond the scope of this text.
See~\cite{codriscv:2017} for more information on computer organization.}

